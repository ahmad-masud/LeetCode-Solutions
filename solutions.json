[
  {
    "id": 1,
    "video": "oetyCTdewlU?si=YVht9LVdy8bIOfaa",
    "overview": "The Two Sum problem is a classic challenge where you need to identify two numbers in an array that add up to a specific target value. The problem requires an efficient approach to traverse the array, keeping track of indices and previously seen numbers to reduce redundant computations. A naive solution involves nested loops, but an optimal solution leverages hash tables to achieve constant-time lookups, making the process much faster and suitable for larger arrays. This problem is a foundational exercise in array traversal and efficient data structure usage.",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Optimal Solution - HashMap",
        "pythonCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n\n        for i, num in enumerate(nums):\n            diff = target - num\n\n            if diff in num_map:\n                return [num_map[diff], i]\n\n            num_map[num] = i",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 11,
    "video": "SxaQPGj5PLg?si=8N_m2Tk7nHCF1dlB",
    "overview": "The Container With Most Water problem involves determining the maximum amount of water that can be contained between two vertical lines, represented as heights in an array. This problem explores two-pointer techniques, where one pointer starts at the beginning and the other at the end of the array, gradually narrowing down to maximize the area. The key insight is to move the pointer associated with the smaller height, as this could lead to a larger container. The problem teaches optimization strategies while maintaining linear time complexity.",
    "solutions": [
      {
        "title": "Brute Force",
        "pythonCode": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        res = 0\n\n        for i in range(len(height)):\n            for j in range(i + 1, len(height)):\n                area = (j - i) * min(height[i], height[j])\n                res = max(res, area)\n                \n        return res",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Two Pointers",
        "pythonCode": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        res = 0\n        l = 0\n        r = len(height) - 1\n\n        while l < r:\n            area = (r - l) * min(height[l], height[r])\n            res = max(res, area)\n\n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 13,
    "video": "iK0CCGldvw4?si=iogrXudOQp946u2P",
    "overview": "The Roman to Integer problem involves converting a Roman numeral string into its equivalent integer value. The challenge lies in understanding the rules for Roman numerals, particularly when smaller numerals precede larger ones to indicate subtraction. A mapping of Roman characters to their integer values is essential, along with careful handling of cases where subtraction rules apply. This problem reinforces the use of hash maps and iterative traversal for string-based computations.",
    "solutions": [
      {
        "title": "Subtractive Notation Handling for Roman to Integer",
        "pythonCode": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        dic = {\n            'I': 1, \n            'V': 5, \n            'X': 10, \n            'L': 50, \n            'C': 100, \n            'D': 500, \n            'M': 1000\n        }\n        res = 0\n\n        for i in range(len(s)):\n            if i < len(s) - 1 and dic[s[i]] < dic[s[i + 1]]:\n                res -= dic[s[i]]\n            else:\n                res += dic[s[i]]\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 14,
    "video": "ALgs0EH1jTo?si=Ei5TxWCCkwmfXhCm",
    "overview": "The Longest Common Prefix problem requires finding the longest prefix shared among an array of strings. A naive approach involves comparing characters of all strings one by one, but a more efficient method involves vertical or horizontal scanning. This problem highlights the importance of string traversal techniques and demonstrates how to optimize performance for repetitive tasks.",
    "solutions": [
      {
        "title": "Vertical Scanning",
        "pythonCode": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        res = \"\"\n\n        for i in range(len(strs[0])):\n            for s in strs:\n                if i == len(s) or s[i] != strs[0][i]:\n                    return res\n\n            res += strs[0][i]\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 20,
    "video": "tTIKa0xXYmk?si=vOAx0G9yA9pV4i7l",
    "overview": "The Valid Parentheses problem is about determining whether a string containing parentheses is balanced and valid. The solution involves using a stack to keep track of opening brackets and matching them with corresponding closing brackets. This problem emphasizes stack-based data structures and is a foundational exercise in understanding how to process nested or hierarchical data.",
    "solutions": [
      {
        "title": "Stack Solution",
        "pythonCode": "class Solution:\n    def isValid(self, s: str) -> bool:\n        dic = {')': '(', ']': '[', '}': '{'}\n        stack = []\n\n        for c in s:\n            if c in dic:\n                if not stack:\n                    return False\n\n                bracket = stack.pop()\n                if dic[c] != bracket:\n                    return False\n            else:\n                stack.append(c)\n\n        return not stack",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 36,
    "video": "IL2tJYA38-s?si=dX4d76oTK3w8V-Gs",
    "overview": "The Valid Sudoku problem checks whether a given Sudoku board is valid according to the game's rules. The solution requires validating rows, columns, and subgrids independently. This problem emphasizes grid-based reasoning and systematic validation.",
    "solutions": [
      {
        "title": "Brute Force",
        "pythonCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        for r in range(9):\n            seen = set()\n\n            for i in range(9):\n                if board[r][i] == \".\": \n                    continue\n\n                if board[r][i] in seen:\n                    return False\n                \n                seen.add(board[r][i])\n        \n        for c in range(9):\n            seen = set()\n\n            for i in range(9):\n                if board[i][c] == \".\":\n                    continue\n\n                if board[i][c] in seen:\n                    return False\n                \n                seen.add(board[i][c])\n            \n        for b in range(9):\n            seen = set()\n\n            for i in range(3):\n                for j in range(3):\n                    r = (b // 3) * 3 + i\n                    c = (b % 3) * 3 + j\n\n                    if board[r][c] == \".\":\n                        continue\n\n                    if board[r][c] in seen:\n                        return False\n                    \n                    seen.add(board[r][c])\n\n        return True",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Hash Set",
        "pythonCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = defaultdict(set)\n        cols = defaultdict(set)\n        boxes = defaultdict(set)\n\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n\n                if val == '.':\n                    continue\n                \n                box_index = (r // 3, c // 3)\n\n                if val in rows[r] or val in cols[c] or val in boxes[box_index]:\n                    return False\n\n                rows[r].add(val)\n                cols[c].add(val)\n                boxes[box_index].add(val)\n\n        return True",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Bit Mask",
        "pythonCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [0] * 9\n        cols = [0] * 9\n        boxes = [0] * 9\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                \n                val = int(board[r][c]) - 1\n\n                if (1 << val) & rows[r]:\n                    return False\n                \n                if (1 << val) & cols[c]:\n                    return False\n                \n                if (1 << val) & boxes[(r // 3) * 3 + (c // 3)]:\n                    return False\n                    \n                rows[r] |= (1 << val)\n                cols[c] |= (1 << val)\n                \n                boxes[(r // 3) * 3 + (c // 3)] |= (1 << val)\n\n        return True",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 53,
    "video": "zfBUOrv1u4k?si=P3USqAXRpTLHMnbf",
    "overview": "The Maximum Subarray problem seeks the largest sum of any contiguous subarray within an array. Kadane's Algorithm provides an elegant O(n) solution by maintaining a running sum and dynamically updating the maximum sum. This problem highlights dynamic programming concepts.",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_sum = float('-inf')\n\n        for i in range(len(nums)):\n            curr_sum = 0\n            for j in range(i, len(nums)):\n                curr_sum += nums[j]\n                max_sum = max(max_sum, curr_sum)\n\n        return max_sum",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Kadane's Algorithm",
        "pythonCode": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = float('-inf')\n        curr = 0\n\n        for n in nums:\n            curr += n\n            res = max(res, curr)\n\n            if curr < 0:\n                curr = 0\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 78,
    "video": "GHtOJN7RX-0?si=A1OHau29Wj7RQsUY",
    "overview": "The Subsets problem generates all possible subsets of a given array. Using backtracking or iterative approaches, the solution explores combinations systematically. This problem introduces combinatorial generation and recursive problem solving.",
    "solutions": [
      {
        "title": "Backtracking Solution",
        "pythonCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        def backtrack(i: int, curr: List[int]) -> None:\n            if i == len(nums):\n                res.append(curr)\n                return\n\n            backtrack(i + 1, curr + [nums[i]])\n            backtrack(i + 1, curr)\n\n        backtrack(0, [])\n        return res",
        "timeComplexity": "O(2^n * n)",
        "spaceComplexity": "O(2^n * n)"
      },
      {
        "title": "Iterative Solution",
        "pythonCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = [[]]\n\n        for n in nums:\n            res += [curr + [n] for curr in res]\n\n        return res",
        "timeComplexity": "O(2^n * n)",
        "spaceComplexity": "O(2^n)"
      }
    ]
  },
  {
    "id": 88,
    "video": "RXgUvXvLXAI?si=s7z7yajs6OfrIKV-",
    "overview": "The Merge Sorted Array problem involves merging two sorted arrays into one sorted array in place. Using a two-pointer technique, the solution iterates from the back to minimize overwriting. This problem teaches in-place operations and efficient merging.",
    "solutions": [
      {
        "title": "Two Pointers (Start from Beginning)",
        "pythonCode": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        res = []\n        p1 = p2 = 0\n\n        while p1 < m and p2 < n:\n            if nums1[p1] < nums2[p2]:\n                res.append(nums1[p1])\n                p1 += 1\n            else:\n                res.append(nums2[p2])\n                p2 += 1\n\n        while p1 < m:\n            res.append(nums1[p1])\n            p1 += 1\n\n        while p2 < n:\n            res.append(nums2[p2])\n            p2 += 1\n\n        nums1[:m + n] = res",
        "timeComplexity": "O(m + n)",
        "spaceComplexity": "O(m + n)"
      },
      {
        "title": "Two Pointers (Start from End)",
        "pythonCode": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        while m > 0 and n > 0:\n            if nums1[m - 1] >= nums2[n - 1]:\n                nums1[m + n - 1] = nums1[m - 1]\n                m -= 1\n            else:\n                nums1[m + n - 1] = nums2[n - 1]\n                n -= 1\n\n        if n > 0:\n            nums1[:n] = nums2[:n]",
        "timeComplexity": "O(m + n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 94,
    "video": "MR-F70Hawo8?si=YXJUh-30v4xd-PLh",
    "overview": "The Binary Tree Inorder Traversal problem performs an inorder traversal of a binary tree, visiting nodes in the left-root-right order. Both recursive and iterative solutions highlight the importance of stack-based tree traversal.",
    "solutions": [
      {
        "title": "Recursive Solution",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n\n        res = []\n\n        res.extend(self.inorderTraversal(root.left))\n        res.append(root.val)\n        res.extend(self.inorderTraversal(root.right))\n        \n        return res\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative Solution",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        stack = []\n        curr = root\n\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n\n        return res\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 104,
    "video": "mypx8ttap7s?si=lSIz4UgxC5vOhQDQ",
    "overview": "The Maximum Depth of Binary Tree problem measures the depth of a binary tree, which is the number of nodes along the longest path from the root to a leaf. This problem highlights the importance of recursion in tree traversal, as both the left and right subtrees need to be explored to determine the overall depth. The problem can also be solved iteratively using a queue, but the recursive approach is more intuitive. This challenge emphasizes understanding how recursive calls stack and how base cases define the termination of the recursion.",
    "solutions": [
      {
        "title": "Recursive DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        stack = [(root, 1)]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n            res = max(res, depth)\n\n            if node.left:\n                stack.append((node.left, depth + 1))\n                \n            if node.right:\n                stack.append((node.right, depth + 1))\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative BFS",
        "pythonCode": " # Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        queue = deque([(root, 1)])\n        res = 0\n\n        while queue:\n            node, depth = queue.popleft()\n            res = max(res, depth)\n\n            if node.left:\n                queue.append((node.left, depth + 1))\n\n            if node.right:\n                queue.append((node.right, depth + 1))\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 121,
    "video": "t5D4F67kmM0?si=hhnGUi3SmfaiITXZ",
    "overview": "The Best Time to Buy and Sell Stock problem is about maximizing profit from a given array of stock prices, where each element represents the stock price on a specific day. The task is to identify the best day to buy and the best day to sell to achieve maximum profit. The solution involves tracking the minimum price encountered so far and calculating potential profits at each step. This problem emphasizes single-pass solutions and demonstrates the importance of efficient updates in dynamic variables.",
    "solutions": [
      {
        "title": "Two Pointers for Maximum Profit",
        "pythonCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        buy = 0\n        sell = 1\n        res = 0\n\n        while sell < len(prices):\n            res = max(res, prices[sell] - prices[buy])\n\n            if prices[buy] > prices[sell]:\n                buy = sell\n            \n            sell += 1\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 125,
    "video": "npBCIvCTMBs?si=MK7kvBBrJ3lYWDJp",
    "overview": "The Valid Palindrome problem requires determining whether a given string can be considered a palindrome after removing all non-alphanumeric characters and ignoring letter case. The challenge lies in efficiently processing the string while handling edge cases like empty strings and mixed character types. A two-pointer approach is commonly used, where pointers move inward from both ends of the string to check for equality. This problem is an excellent exercise in string manipulation and input validation.",
    "solutions": [
      {
        "title": "Two Pointers with Character Filtering",
        "pythonCode": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l = 0\n        r = len(s) - 1\n\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n                \n            while l < r and not s[r].isalnum():\n                r -= 1\n\n            if s[l].lower() != s[r].lower():\n                return False\n\n            l += 1\n            r -= 1\n\n        return True",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 136,
    "video": "YcusSSCLmKQ?si=HaWWVb-YQGNyZv7z",
    "overview": "The Single Number problem requires finding the unique element in an array where every other element appears twice. The problem can be solved using a hash map to count occurrences or by leveraging the XOR operation, which efficiently cancels out pairs of identical numbers, leaving the unique number. The XOR approach is optimal in terms of both time and space complexity, making it a favorite for algorithm enthusiasts.",
    "solutions": [
      {
        "title": "Brute Force Solution - Using Count",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for n in nums:\n            if nums.count(n) == 1:\n                return n",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Hash Table Solution",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        hash_table = {}\n\n        for n in nums:\n            hash_table[n] = hash_table.get(n, 0) + 1\n\n        for n, count in hash_table.items():\n            if count == 1:\n                return n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Math Set Solution",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return 2 * sum(set(nums)) - sum(nums)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Optimal Solution - Using XOR",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n\n        for n in nums:\n            res ^= n\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 167,
    "video": "-gPXrCoJgHE?si=rmf_JEzpk7aqUHIk",
    "overview": "The Two Sum II problem builds on the classic Two Sum but leverages the fact that the input array is sorted. By using a two-pointer technique, the solution avoids the need for a hash table and achieves optimal performance. The pointers start at opposite ends of the array, and their positions are adjusted based on the sum of their values relative to the target. This problem showcases the efficiency gained from sorted data.",
    "solutions": [
      {
        "title": "Two-Pointer Technique",
        "pythonCode": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l = 0\n        r = len(numbers) - 1\n\n        while l < r:\n            curr_sum = numbers[l] + numbers[r]\n            \n            if curr_sum == target:\n                return [l + 1, r + 1]\n            elif curr_sum < target:\n                l += 1\n            else:\n                r -= 1",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 191,
    "video": null,
    "overview": "The Number of 1 Bits problem involves counting the number of `1` bits in the binary representation of an integer. The challenge focuses on bit manipulation techniques, such as repeatedly shifting the bits and using bitwise AND operations to isolate individual bits. This problem serves as a gateway to understanding low-level binary operations and their applications in programming.",
    "solutions": [
      {
        "title": "Count Bits with Bitwise AND",
        "pythonCode": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n\n        while n:\n            res += n & 1\n            n >>= 1\n\n        return res",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Count Bits Using Bit Manipulation Trick",
        "pythonCode": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n\n        while n:\n            n &= n - 1\n            res += 1\n\n        return res",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 200,
    "video": "ScvAGc6yBs4?si=qRcnTKoBhYhbcKZT",
    "overview": "The Number of Islands problem involves finding and counting distinct islands in a 2D grid where `1` represents land and `0` represents water. Using either depth-first search (DFS) or breadth-first search (BFS), the problem explores graph traversal techniques and how to mark visited nodes. It is a classic exercise in flood-fill algorithms and spatial reasoning.",
    "solutions": [
      {
        "title": "Depth-First Search (DFS) Solution",
        "pythonCode": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        res = 0\n\n        def dfs(r: int, c: int) -> None:\n            if r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == '0':\n                return\n\n            grid[r][c] = '0'\n\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == '1':\n                    res += 1\n                    dfs(r, c)\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(n * m)"
      },
      {
        "title": "Breadth-First Search (BFS) Solution",
        "pythonCode": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        res = 0\n\n        def bfs(r: int, c: int) -> None:\n            queue = deque([(r, c)])\n            grid[r][c] = '0'\n\n            while queue:\n                row, col = queue.popleft()\n\n                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nr, nc = row + dr, col + dc\n\n                    if 0 <= nr < ROWS and 0 <= nc < COLS and grid[nr][nc] == '1':\n                        grid[nr][nc] = '0'\n                        queue.append((nr, nc))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == '1':\n                    res += 1\n                    bfs(r, c)\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(min(n, m))"
      }
    ]
  },
  {
    "id": 205,
    "video": "vlyFirJRYjE?si=e1eUJe_B6afb8yNT",
    "overview": "The Isomorphic Strings problem checks if two strings can be transformed into each other by creating a one-to-one mapping between characters. The challenge is to ensure the mapping is consistent and bidirectional, often requiring two hash maps to track forward and reverse mappings. This problem emphasizes bijective transformations and edge-case handling.",
    "solutions": [
      {
        "title": "Hash Table Tracking",
        "pythonCode": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        dic1 = {}\n        dic2 = {}\n        \n        for i in range(len(s)):\n            if (s[i] in dic1 and dic1[s[i]] != t[i]):\n                return False\n            \n            if (t[i] in dic2 and dic2[t[i]] != s[i]):\n                return False\n            \n            dic1[s[i]] = t[i]\n            dic2[t[i]] = s[i]\n\n        return True",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 206,
    "video": "skePaM3nA2w?si=dG_NH3eyfnq5FMyE",
    "overview": "The Reverse Linked List problem involves reversing the order of nodes in a singly linked list. The iterative solution uses three pointers to traverse and reverse the list, while the recursive solution leverages the call stack. This problem is a classic exercise in linked list manipulation and pointer management.",
    "solutions": [
      {
        "title": "Iterative Solution",
        "pythonCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Recursive Solution",
        "pythonCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        reversed_head = reverseList(head.next)\n        head.next.next = head\n        head.next = None\n\n        return reversed_head\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 209,
    "video": "qgsXwaG2nvs?si=wpkI_l6-E8zZjpzM",
    "overview": "The Minimum Size Subarray Sum problem requires finding the smallest contiguous subarray with a sum greater than or equal to a target value. Using the sliding window technique, the solution dynamically adjusts the window size to balance efficiency and correctness. This problem demonstrates how to optimize array traversal with minimal overhead.",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        res = float('inf')\n\n        for i in range(len(nums)):\n            curr_sum = 0\n\n            for j in range(i, len(nums)):\n                curr_sum += nums[j]\n\n                if curr_sum >= target:\n                    res = min(res, j - i + 1)\n                    break\n\n        return res if res != float('inf') else 0",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Sliding Window Solution",
        "pythonCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        l = 0\n        prefix_sum = 0\n        res = float('inf')\n\n        for r in range(len(nums)):\n            prefix_sum += nums[r]\n\n            while prefix_sum >= target:\n                res = min(res, r - l + 1)\n                prefix_sum -= nums[l]\n                l += 1\n\n        return res if res != float('inf') else 0",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 217,
    "video": "HXqyNLDyqp0?si=EFcH5z_209mPw-YR",
    "overview": "The Contains Duplicate problem asks if an array contains any duplicate elements. While the brute force approach involves nested loops, an optimal solution uses hash sets to track seen elements in linear time. This problem is a straightforward yet critical exercise in leveraging efficient data structures.",
    "solutions": [
      {
        "title": "Brute-Force Approach",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    return True\n                \n        return False",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Using a Hash Set",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        seen = set()\n\n        for n in nums:\n            if n in seen:\n                return True\n            \n            seen.add(n)\n            \n        return False",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Using Sorting",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        nums.sort()\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                return True\n            \n        return False",
        "timeComplexity": "O(nlogn)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Using a Counter",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        count = Counter(nums)\n\n        for key in count:\n            if count[key] > 1:\n                return True\n            \n        return False\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Using a Dictionary",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        counts = {}\n\n        for n in nums:\n            if n in counts:\n                return True\n            \n            counts[n] = 1\n\n        return False",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Using Python's len Comparison with a Set",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        return len(nums) != len(set(nums))",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 226,
    "video": "njhJLhgM8jw?si=CA70QIT6L4PotYB5",
    "overview": "The Invert Binary Tree problem involves swapping the left and right children of every node in a binary tree. It can be solved recursively or iteratively and is a fundamental exercise in tree manipulation and recursion.",
    "solutions": [
      {
        "title": "Recursive DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n\n        if not root.left and not root.right:\n            return root\n\n        root.left, root.right = root.right, root.left\n\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            node.left, node.right = node.right, node.left\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Iterative BFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n\n        queue = [root]\n\n        while queue:\n            node = queue.pop(0)\n            node.left, node.right = node.right, node.left\n            \n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Morris Traversal",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n\n        curr = root\n        \n        while curr:\n            curr.left, curr.right = curr.right, curr.left\n            curr = curr.left\n\n        if root:\n            curr = root.right\n\n            while curr:\n                curr.left, curr.right = curr.right, curr.left\n                curr = curr.left\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 228,
    "video": "9TzRVIW3Gpk?si=iZYrbL40MzcJuWcM",
    "overview": "The Summary Ranges problem generates concise descriptions of ranges in a sorted array of integers. It requires iterating through the array while identifying consecutive sequences. The challenge lies in efficiently managing boundaries and formatting the output.",
    "solutions": [
      {
        "title": "Range Grouping with Two Pointers",
        "pythonCode": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        res = []\n\n        if not nums:\n            return res\n        \n        start = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1] + 1:\n                if start == nums[i - 1]:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{nums[i - 1]}\")\n                    \n                start = nums[i]\n        \n        if nums[-1] == start:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{nums[-1]}\")\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 238,
    "video": "htvDp0R3C6s?si=shx2n-PoKUjbDumX",
    "overview": "The Product of Array Except Self problem involves calculating the product of all elements in an array except the current one. The solution avoids division and achieves O(n) time complexity using prefix and suffix products. This problem is a classic demonstration of space-time trade-offs.",
    "solutions": [
      {
        "title": "Prefix and Suffix Product",
        "pythonCode": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n        prefix = 1\n\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        suffix = 1\n        \n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= suffix\n            suffix *= nums[i]\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 242,
    "video": "KG9GTX9oqss?si=IIPKz_m82uKnPfSe",
    "overview": "The Valid Anagram problem checks if two strings are anagrams by comparing character frequencies. Sorting the strings is a simple solution, but using hash maps for frequency counting is more efficient. This problem highlights string manipulation and frequency analysis.",
    "solutions": [
      {
        "title": "Sorting and Comparison",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return sorted(s) == sorted(t)",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Array Counting for Fixed Alphabet",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        count = [0] * 26\n\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n\n        for c in t:\n            count[ord(c) - ord('a')] -= 1\n\n            if count[ord(c) - ord('a')] < 0:\n                return False\n\n        return True",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Manual Hash Table Implementation",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        count = {}\n\n        for c in s:\n            count[c] = count.get(c, 0) + 1\n\n        for c in t:\n            if c not in count or count[c] == 0:\n                return False\n            \n            count[c] -= 1\n\n        for n in count.values():\n            if n != 0:\n                return False\n\n        return True",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Hash Table Character Frequency Count",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return Counter(s) == Counter(t)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 344,
    "video": "QmvMuRcnIZ8?si=yll0E7OyDREY5ogu",
    "overview": "The Reverse String problem asks you to reverse a given string in place using minimal space. By employing a two-pointer approach, the solution swaps characters at opposite ends until the pointers meet. This problem reinforces basic array manipulation and pointer techniques.",
    "solutions": [
      {
        "title": "Two Pointer Solution",
        "pythonCode": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            s[l], s[r] = s[r], s[l]\n            l += 1\n            r -= 1",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Recursive Solution",
        "pythonCode": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        def helper(l, r):\n            if l >= r:\n                return\n            \n            s[l], s[r] = s[r], s[l]\n            helper(l + 1, r - 1)\n\n        helper(0, len(s) - 1)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 347,
    "video": "-kBTgY7E0EU?si=w2wfHWgAdTk1zDKd",
    "overview": "The Top K Frequent Elements problem requires finding the K most frequent elements in an array. Using hash maps for frequency counting and heaps for efficient retrieval, the solution balances speed and memory usage. This problem demonstrates advanced data structure applications.",
    "solutions": [
      {
        "title": "Sorting Approach",
        "pythonCode": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = Counter(nums)\n        freq = sorted(count.keys(), key=lambda x: count[x], reverse=True)\n        \n        return freq[:k]",
        "timeComplexity": "O(nlogn)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Heap Approach",
        "pythonCode": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = Counter(nums)\n        heap = []\n\n        for n, c in count.items():\n            heapq.heappush(heap, (c, n))\n\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        return [n for c, n in heap]",
        "timeComplexity": "O(nlogk)",
        "spaceComplexity": "O(n + k)"
      },
      {
        "title": "Bucket Sort Approach",
        "pythonCode": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = Counter(nums)\n        bucket = [[] for _ in range(len(nums) + 1)]\n\n        for n, c in count.items():\n            bucket[c].append(n)\n        \n        res = []\n\n        for i in range(len(bucket) - 1, 0, -1):\n            for n in bucket[i]:\n                res.append(n)\n\n                if len(res) == k:\n                    return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 349,
    "video": "Lcj_cuZUy68?si=3Gqo9JgWimF9MuRB",
    "overview": "The Intersection of Two Arrays problem involves finding common elements between two arrays. By using sets for fast lookups, the solution avoids redundant comparisons and achieves optimal performance. This problem emphasizes set operations and their real-world applications.",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> int:\n        res = []\n\n        for n in nums1:\n            if n in nums2 and n not in res:\n                res.append(n)\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(min(n, m))"
      },
      {
        "title": "Hash Set Solution",
        "pythonCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> int:\n        set1 = set(nums1)\n        set2 = set(nums2)\n\n        return list(set1 & set2)",
        "timeComplexity": "O(n + m)",
        "spaceComplexity": "O(n + m)"
      },
      {
        "title": "Two Pointer Solution - Sorted Arrays",
        "pythonCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> int:\n        nums1.sort()\n        nums2.sort()\n        i, j = 0, 0\n        res = set()\n\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.add(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n\n        return list(res)",
        "timeComplexity": "O(n log n + m log m)",
        "spaceComplexity": "O(min(n, m))"
      }
    ]
  },
  {
    "id": 704,
    "video": "PBnAF8zxBVw?si=w7JuvitYAtMSDsSI",
    "overview": "The Binary Search problem involves searching for a target element in a sorted array using the divide-and-conquer principle. The solution achieves O(log n) time complexity and is a foundational algorithm in computer science.",
    "solutions": [
      {
        "title": "Iterative Binary Search",
        "pythonCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            m = l + (r - l) // 2\n\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n\n        return -1",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Recursive Binary Search",
        "pythonCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        def binary_search(l, r):\n            if l > r:\n                return -1\n\n            m = l + (r - l) // 2\n\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                return binary_search(m + 1, r)\n            else:\n                return binary_search(l, m - 1)\n\n        return binary_search(0, len(nums) - 1)",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(log n)"
      }
    ]
  },
  {
    "id": 763,
    "video": "sry1ERSzKtw?si=_-ezcqOs1CifkhAJ",
    "overview": "The Partition Labels problem divides a string into as many parts as possible, ensuring that each letter appears in only one part. The solution uses greedy algorithms and character frequency tracking. This problem emphasizes optimal partitioning strategies.",
    "solutions": [
      {
        "title": "Two Pointers",
        "pythonCode": "class Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        last = {c: i for i, c in enumerate(s)}\n        res = []\n        start = end = 0\n\n        for i, c in enumerate(s):\n            end = max(end, last[c])\n\n            if i == end:\n                res.append(end - start + 1)\n                start = i + 1\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 1046,
    "video": "TECAKV7m2F0?si=mSh8pl_lNoRgGHxs",
    "overview": "The \"Last Stone Weight\" problem is a simulation-based question where you repeatedly smash the two heaviest stones in a list until at most one stone remains. If the two stones have equal weight, both are destroyed. If they have different weights, the smaller one is destroyed, and the larger one is reduced by the smaller stone's weight. This process continues until no more than one stone is left, and the task is to return the weight of that stone or `0` if all stones are destroyed. The problem involves prioritizing the heaviest stones in each iteration, making it suitable for approaches like heaps, sorting, or direct simulation. Efficient solutions focus on minimizing the overhead of repeatedly finding and updating the heaviest stones.",
    "solutions": [
      {
        "title": "Manual Simulation",
        "pythonCode": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        while len(stones) > 1:\n            max1 = max(stones)\n            stones.remove(max1)\n\n            max2 = max(stones)\n            stones.remove(max2)\n        \n            if max1 != max2:\n                stones.append(max1 - max2)\n    \n        return stones[0] if stones else 0",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Sorting",
        "pythonCode": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        while len(stones) > 1:\n            stones.sort()\n            y = stones.pop()\n            x = stones.pop()\n            \n            if x != y:\n                stones.append(y - x)\n    \n        return stones[0] if stones else 0",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Max Heap - Optimal Solution",
        "pythonCode": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n        \n        while len(stones) > 1:\n            y = -heapq.heappop(stones)\n            x = -heapq.heappop(stones)\n            \n            if x != y:\n                heapq.heappush(stones, -(y - x))\n        \n        return -stones[0] if stones else 0",
        "timeComplexity": "O(nlogn)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 1768,
    "video": "6tqnIGynncU?si=H1Pz6ncVs3a_F5cK",
    "overview": "The Merge Strings Alternately problem asks you to merge two strings character by character, alternating between them. If one string is longer than the other, the remaining characters are appended to the result. The task emphasizes careful iteration over strings with different lengths and demonstrates how to combine elements from multiple sources in a structured manner.",
    "solutions": [
      {
        "title": "Alternating Merge",
        "pythonCode": "class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        res = []\n        i = 0\n\n        while i < len(word1) or i < len(word2):\n            if i < len(word1):\n                res.append(word1[i])\n                \n            if i < len(word2):\n                res.append(word2[i])\n\n            i += 1\n\n        return ''.join(res)",
        "timeComplexity": "O(n + m)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 2239,
    "video": "8VOP4Mm4nFs?si=GMR-G8DNP7sHt-s8",
    "overview": "The Find Closest Number to Zero problem involves finding the number closest to zero in an array. If there are ties, the positive number is preferred. The task requires careful comparisons and handling of edge cases involving negative numbers and zeros.",
    "solutions": [
      {
        "title": "Alternative Approach - Sorting",
        "pythonCode": "class Solution:\n    def findClosestNumber(self, nums: List[int]) -> int:\n        nums.sort(key=lambda x: (abs(x), -x))\n        return nums[0]",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Optimal Solution - Linear Time",
        "pythonCode": "class Solution:\n    def findClosestNumber(self, nums: List[int]) -> int:\n        res = float('inf')\n\n        for n in nums:\n            if abs(n) < abs(res):\n                res = n\n            elif abs(n) == abs(res):\n                res = max(n, res)\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  }
]
