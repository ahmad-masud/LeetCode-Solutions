[
  {
    "id": 1,
    "video": "oetyCTdewlU?si=YVht9LVdy8bIOfaa",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Optimal Solution - HashMap",
        "pythonCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n\n        for i, num in enumerate(nums):\n            diff = target - num\n\n            if diff in num_map:\n                return [num_map[diff], i]\n\n            num_map[num] = i",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 13,
    "video": "iK0CCGldvw4?si=iogrXudOQp946u2P",
    "solutions": [
      {
        "title": "Subtractive Notation Handling for Roman to Integer",
        "pythonCode": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        dic = {\n            'I': 1, \n            'V': 5, \n            'X': 10, \n            'L': 50, \n            'C': 100, \n            'D': 500, \n            'M': 1000\n        }\n        res = 0\n\n        for i in range(len(s)):\n            if i < len(s) - 1 and dic[s[i]] < dic[s[i + 1]]:\n                res -= dic[s[i]]\n            else:\n                res += dic[s[i]]\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 14,
    "video": "ALgs0EH1jTo?si=Ei5TxWCCkwmfXhCm",
    "solutions": [
      {
        "title": "Vertical Scanning",
        "pythonCode": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        res = \"\"\n\n        for i in range(len(strs[0])):\n            for s in strs:\n                if i == len(s) or s[i] != strs[0][i]:\n                    return res\n\n            res += strs[0][i]\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 20,
    "video": "tTIKa0xXYmk?si=vOAx0G9yA9pV4i7l",
    "solutions": [
      {
        "title": "Stack Solution",
        "pythonCode": "class Solution:\n    def isValid(self, s: str) -> bool:\n        dic = {')': '(', ']': '[', '}': '{'}\n        stack = []\n\n        for c in s:\n            if c in dic:\n                if not stack:\n                    return False\n\n                bracket = stack.pop()\n                if dic[c] != bracket:\n                    return False\n            else:\n                stack.append(c)\n\n        return not stack",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 36,
    "video": "IL2tJYA38-s?si=dX4d76oTK3w8V-Gs",
    "solutions": [
      {
        "title": "Brute Force",
        "pythonCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        for r in range(9):\n            seen = set()\n\n            for i in range(9):\n                if board[r][i] == \".\": \n                    continue\n\n                if board[r][i] in seen:\n                    return False\n                \n                seen.add(board[r][i])\n        \n        for c in range(9):\n            seen = set()\n\n            for i in range(9):\n                if board[i][c] == \".\":\n                    continue\n\n                if board[i][c] in seen:\n                    return False\n                \n                seen.add(board[i][c])\n            \n        for b in range(9):\n            seen = set()\n\n            for i in range(3):\n                for j in range(3):\n                    r = (b // 3) * 3 + i\n                    c = (b % 3) * 3 + j\n\n                    if board[r][c] == \".\":\n                        continue\n\n                    if board[r][c] in seen:\n                        return False\n                    \n                    seen.add(board[r][c])\n\n        return True",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Hash Set",
        "pythonCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = defaultdict(set)\n        cols = defaultdict(set)\n        boxes = defaultdict(set)\n\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n\n                if val == '.':\n                    continue\n                \n                box_index = (r // 3, c // 3)\n\n                if val in rows[r] or val in cols[c] or val in boxes[box_index]:\n                    return False\n\n                rows[r].add(val)\n                cols[c].add(val)\n                boxes[box_index].add(val)\n\n        return True",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Bit Mask",
        "pythonCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [0] * 9\n        cols = [0] * 9\n        boxes = [0] * 9\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                \n                val = int(board[r][c]) - 1\n\n                if (1 << val) & rows[r]:\n                    return False\n                \n                if (1 << val) & cols[c]:\n                    return False\n                \n                if (1 << val) & boxes[(r // 3) * 3 + (c // 3)]:\n                    return False\n                    \n                rows[r] |= (1 << val)\n                cols[c] |= (1 << val)\n                \n                boxes[(r // 3) * 3 + (c // 3)] |= (1 << val)\n\n        return True",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 53,
    "video": "zfBUOrv1u4k?si=P3USqAXRpTLHMnbf",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_sum = float('-inf')\n\n        for i in range(len(nums)):\n            curr_sum = 0\n            for j in range(i, len(nums)):\n                curr_sum += nums[j]\n                max_sum = max(max_sum, curr_sum)\n\n        return max_sum",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Kadane's Algorithm",
        "pythonCode": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = float('-inf')\n        curr = 0\n\n        for n in nums:\n            curr += n\n            res = max(res, curr)\n\n            if curr < 0:\n                curr = 0\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 78,
    "video": "GHtOJN7RX-0?si=A1OHau29Wj7RQsUY",
    "solutions": [
      {
        "title": "Backtracking Solution",
        "pythonCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        def backtrack(i: int, curr: List[int]) -> None:\n            if i == len(nums):\n                res.append(curr)\n                return\n\n            backtrack(i + 1, curr + [nums[i]])\n            backtrack(i + 1, curr)\n\n        backtrack(0, [])\n        return res",
        "timeComplexity": "O(2^n * n)",
        "spaceComplexity": "O(2^n * n)"
      },
      {
        "title": "Iterative Solution",
        "pythonCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = [[]]\n\n        for n in nums:\n            res += [curr + [n] for curr in res]\n\n        return res",
        "timeComplexity": "O(2^n * n)",
        "spaceComplexity": "O(2^n)"
      }
    ]
  },
  {
    "id": 94,
    "video": "MR-F70Hawo8?si=YXJUh-30v4xd-PLh",
    "solutions": [
      {
        "title": "Recursive Solution",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n\n        res = []\n\n        res.extend(self.inorderTraversal(root.left))\n        res.append(root.val)\n        res.extend(self.inorderTraversal(root.right))\n        \n        return  res\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative Solution",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        stack = []\n        curr = root\n\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n\n        return res\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 104,
    "video": "mypx8ttap7s?si=lSIz4UgxC5vOhQDQ",
    "solutions": [
      {
        "title": "Recursive DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        stack = [(root, 1)]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n            res = max(res, depth)\n\n            if node.left:\n                stack.append((node.left, depth + 1))\n                \n            if node.right:\n                stack.append((node.right, depth + 1))\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative BFS",
        "pythonCode": " # Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        queue = deque([(root, 1)])\n        res = 0\n\n        while queue:\n            node, depth = queue.popleft()\n            res = max(res, depth)\n\n            if node.left:\n                queue.append((node.left, depth + 1))\n\n            if node.right:\n                queue.append((node.right, depth + 1))\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 121,
    "video": "t5D4F67kmM0?si=hhnGUi3SmfaiITXZ",
    "solutions": [
      {
        "title": "Two Pointers for Maximum Profit",
        "pythonCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        buy = 0\n        sell = 1\n        res = 0\n\n        while sell < len(prices):\n            res = max(res, prices[sell] - prices[buy])\n\n            if prices[buy] > prices[sell]:\n                buy = sell\n            \n            sell += 1\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 125,
    "video": "npBCIvCTMBs?si=MK7kvBBrJ3lYWDJp",
    "solutions": [
      {
        "title": "Two Pointers with Character Filtering",
        "pythonCode": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l = 0\n        r = len(s) - 1\n\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n                \n            while l < r and not s[r].isalnum():\n                r -= 1\n\n            if s[l].lower() != s[r].lower():\n                return False\n\n            l += 1\n            r -= 1\n\n        return True",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 136,
    "video": "YcusSSCLmKQ?si=HaWWVb-YQGNyZv7z",
    "solutions": [
      {
        "title": "Brute Force Solution - Using Count",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for n in nums:\n            if nums.count(n) == 1:\n                return n",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Hash Table Solution",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        hash_table = {}\n\n        for n in nums:\n            hash_table[n] = hash_table.get(n, 0) + 1\n\n        for n, count in hash_table.items():\n            if count == 1:\n                return n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Math Set Solution",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return 2 * sum(set(nums)) - sum(nums)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Optimal Solution - Using XOR",
        "pythonCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n\n        for n in nums:\n            res ^= n\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 167,
    "video": "-gPXrCoJgHE?si=rmf_JEzpk7aqUHIk",
    "solutions": [
      {
        "title": "Two-Pointer Technique",
        "pythonCode": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l = 0\n        r = len(numbers) - 1\n\n        while l < r:\n            curr_sum = numbers[l] + numbers[r]\n            \n            if curr_sum == target:\n                return [l + 1, r + 1]\n            elif curr_sum < target:\n                l += 1\n            else:\n                r -= 1",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 191,
    "video": null,
    "solutions": [
      {
        "title": "Count Bits with Bitwise AND",
        "pythonCode": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n\n        while n:\n            res += n & 1\n            n >>= 1\n\n        return res",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Count Bits Using Bit Manipulation Trick",
        "pythonCode": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n\n        while n:\n            n &= n - 1\n            res += 1\n\n        return res",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 200,
    "video": "ScvAGc6yBs4?si=qRcnTKoBhYhbcKZT",
    "solutions": [
      {
        "title": "Depth-First Search (DFS) Solution",
        "pythonCode": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        res = 0\n\n        def dfs(r: int, c: int) -> None:\n            if r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == '0':\n                return\n\n            grid[r][c] = '0'\n\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == '1':\n                    res += 1\n                    dfs(r, c)\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(n * m)"
      },
      {
        "title": "Breadth-First Search (BFS) Solution",
        "pythonCode": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        res = 0\n\n        def bfs(r: int, c: int) -> None:\n            queue = deque([(r, c)])\n            grid[r][c] = '0'\n\n            while queue:\n                row, col = queue.popleft()\n\n                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nr, nc = row + dr, col + dc\n\n                    if 0 <= nr < ROWS and 0 <= nc < COLS and grid[nr][nc] == '1':\n                        grid[nr][nc] = '0'\n                        queue.append((nr, nc))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == '1':\n                    res += 1\n                    bfs(r, c)\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(min(n, m))"
      }
    ]
  },
  {
    "id": 205,
    "video": "vlyFirJRYjE?si=e1eUJe_B6afb8yNT",
    "solutions": [
      {
        "title": "Hash Table Tracking",
        "pythonCode": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        dic1 = {}\n        dic2 = {}\n        \n        for i in range(len(s)):\n            if (s[i] in dic1 and dic1[s[i]] != t[i]):\n                return False\n            \n            if (t[i] in dic2 and dic2[t[i]] != s[i]):\n                return False\n            \n            dic1[s[i]] = t[i]\n            dic2[t[i]] = s[i]\n\n        return True",
        "timeComplexity": "",
        "spaceComplexity": ""
      }
    ]
  },
  {
    "id": 206,
    "video": "skePaM3nA2w?si=dG_NH3eyfnq5FMyE",
    "solutions": [
      {
        "title": "Iterative Solution",
        "pythonCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Recursive Solution",
        "pythonCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        reversed_head = reverseList(head.next)\n        head.next.next = head\n        head.next = None\n\n        return reversed_head\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 209,
    "video": "qgsXwaG2nvs?si=wpkI_l6-E8zZjpzM",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        res = float('inf')\n\n        for i in range(len(nums)):\n            curr_sum = 0\n\n            for j in range(i, len(nums)):\n                curr_sum += nums[j]\n\n                if curr_sum >= target:\n                    res = min(res, j - i + 1)\n                    break\n\n        return res if res != float('inf') else 0",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Sliding Window Solution",
        "pythonCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        l = 0\n        prefix_sum = 0\n        res = float('inf')\n\n        for r in range(len(nums)):\n            prefix_sum += nums[r]\n\n            while prefix_sum >= target:\n                res = min(res, r - l + 1)\n                prefix_sum -= nums[l]\n                l += 1\n\n        return res if res != float('inf') else 0",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 217,
    "video": "HXqyNLDyqp0?si=EFcH5z_209mPw-YR",
    "solutions": [
      {
        "title": "Brute-Force Approach",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    return True\n                \n        return False",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Using a Hash Set",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        seen = set()\n\n        for n in nums:\n            if n in seen:\n                return True\n            \n            seen.add(n)\n            \n        return False",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Using Sorting",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        nums.sort()\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                return True\n            \n        return False",
        "timeComplexity": "O(nlogn)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Using a Counter",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        count = Counter(nums)\n\n        for key in count:\n            if count[key] > 1:\n                return True\n            \n        return False\n",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Using a Dictionary",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        counts = {}\n\n        for n in nums:\n            if n in counts:\n                return True\n            \n            counts[n] = 1\n\n        return False",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Using Python's len Comparison with a Set",
        "pythonCode": "class Solution:\n    def containsDuplicate(self, nums):\n        return len(nums) != len(set(nums))",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 226,
    "video": "njhJLhgM8jw?si=CA70QIT6L4PotYB5",
    "solutions": [
      {
        "title": "Recursive DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n\n        if not root.left and not root.right:\n            return root\n\n        root.left, root.right = root.right, root.left\n\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Iterative DFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            node.left, node.right = node.right, node.left\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Iterative BFS",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n\n        queue = [root]\n\n        while queue:\n            node = queue.pop(0)\n            node.left, node.right = node.right, node.left\n            \n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Morris Traversal",
        "pythonCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n\n        curr = root\n        \n        while curr:\n            curr.left, curr.right = curr.right, curr.left\n            curr = curr.left\n\n        if root:\n            curr = root.right\n\n            while curr:\n                curr.left, curr.right = curr.right, curr.left\n                curr = curr.left\n\n        return root",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 228,
    "video": "9TzRVIW3Gpk?si=iZYrbL40MzcJuWcM",
    "solutions": [
      {
        "title": "Range Grouping with Two Pointers",
        "pythonCode": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        res = []\n\n        if not nums:\n            return res\n        \n        start = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1] + 1:\n                if start == nums[i - 1]:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{nums[i - 1]}\")\n                    \n                start = nums[i]\n        \n        if nums[-1] == start:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{nums[-1]}\")\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 238,
    "video": "htvDp0R3C6s?si=shx2n-PoKUjbDumX",
    "solutions": [
      {
        "title": "Prefix and Suffix Product",
        "pythonCode": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n        prefix = 1\n\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        suffix = 1\n        \n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= suffix\n            suffix *= nums[i]\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 242,
    "video": "KG9GTX9oqss?si=IIPKz_m82uKnPfSe",
    "solutions": [
      {
        "title": "Sorting and Comparison",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return sorted(s) == sorted(t)",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)"
      },
      {
        "title": "Array Counting for Fixed Alphabet",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        count = [0] * 26\n\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n\n        for c in t:\n            count[ord(c) - ord('a')] -= 1\n\n            if count[ord(c) - ord('a')] < 0:\n                return False\n\n        return True",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Manual Hash Table Implementation",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        count = {}\n\n        for c in s:\n            count[c] = count.get(c, 0) + 1\n\n        for c in t:\n            if c not in count or count[c] == 0:\n                return False\n            \n            count[c] -= 1\n\n        for n in count.values():\n            if n != 0:\n                return False\n\n        return True",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Hash Table Character Frequency Count",
        "pythonCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return Counter(s) == Counter(t)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 344,
    "video": "QmvMuRcnIZ8?si=yll0E7OyDREY5ogu",
    "solutions": [
      {
        "title": "Two Pointer Solution",
        "pythonCode": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            s[l], s[r] = s[r], s[l]\n            l += 1\n            r -= 1",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Recursive Solution",
        "pythonCode": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        def helper(l, r):\n            if l >= r:\n                return\n            \n            s[l], s[r] = s[r], s[l]\n            helper(l + 1, r - 1)\n\n        helper(0, len(s) - 1)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
    ]
  },
  {
    "id": 349,
    "video": "Lcj_cuZUy68?si=3Gqo9JgWimF9MuRB",
    "solutions": [
      {
        "title": "Brute Force Solution",
        "pythonCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> int:\n        res = []\n\n        for n in nums1:\n            if n in nums2 and n not in res:\n                res.append(n)\n\n        return res",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(min(n, m))"
      },
      {
        "title": "Hash Set Solution",
        "pythonCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> int:\n        set1 = set(nums1)\n        set2 = set(nums2)\n\n        return list(set1 & set2)",
        "timeComplexity": "O(n + m)",
        "spaceComplexity": "O(n + m)"
      },
      {
        "title": "Two Pointer Solution - Sorted Arrays",
        "pythonCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> int:\n        nums1.sort()\n        nums2.sort()\n        i, j = 0, 0\n        res = set()\n\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.add(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n\n        return list(res)",
        "timeComplexity": "O(n log n + m log m)",
        "spaceComplexity": "O(min(n, m))"
      }
    ]
  },
  {
    "id": 704,
    "video": "PBnAF8zxBVw?si=w7JuvitYAtMSDsSI",
    "solutions": [
      {
        "title": "Iterative Binary Search",
        "pythonCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            m = l + (r - l) // 2\n\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n\n        return -1",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Recursive Binary Search",
        "pythonCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        def binary_search(l, r):\n            if l > r:\n                return -1\n\n            m = l + (r - l) // 2\n\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                return binary_search(m + 1, r)\n            else:\n                return binary_search(l, m - 1)\n\n        return binary_search(0, len(nums) - 1)",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(log n)"
      }
    ]
  },
  {
    "id": 1768,
    "video": "6tqnIGynncU?si=H1Pz6ncVs3a_F5cK",
    "solutions": [
      {
        "title": "Alternating Merge",
        "pythonCode": "class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        res = []\n        i = 0\n\n        while i < len(word1) or i < len(word2):\n            if i < len(word1):\n                res.append(word1[i])\n                \n            if i < len(word2):\n                res.append(word2[i])\n\n            i += 1\n\n        return ''.join(res)",
        "timeComplexity": "O(n + m)",
        "spaceComplexity": "O(1)"
      }
    ]
  },
  {
    "id": 2239,
    "video": "8VOP4Mm4nFs?si=GMR-G8DNP7sHt-s8",
    "solutions": [
      {
        "title": "Alternative Approach - Sorting",
        "pythonCode": "class Solution:\n    def findClosestNumber(self, nums: List[int]) -> int:\n        nums.sort(key=lambda x: (abs(x), -x))\n        return nums[0]",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)"
      },
      {
        "title": "Optimal Solution - Linear Time",
        "pythonCode": "class Solution:\n    def findClosestNumber(self, nums: List[int]) -> int:\n        res = float('inf')\n\n        for n in nums:\n            if abs(n) < abs(res):\n                res = n\n            elif abs(n) == abs(res):\n                res = max(n, res)\n\n        return res",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ]
  }
]
